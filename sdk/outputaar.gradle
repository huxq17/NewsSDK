import java.text.SimpleDateFormat

def aarPath = buildDir.path + "/outputs/aar/"
def aarlibPath = aarPath + "libs/"

def buildTime() {
    def df = new SimpleDateFormat("yyyyMMdd")
    df.setTimeZone(TimeZone.getDefault())
    return df.format(new Date())
}

def getJarName() {
    return "NEWSSDK" + sdkVersion() + "_" + PACKAGE_TYPE
}

def getAARName() {
    return "NEWSSDK" + buildTime() + sdkVersion() + "_" + PACKAGE_TYPE + ".aar"
}

def getToolkitName() {
    return "toolkit" + buildTime() + sdkVersion() + "_" + PACKAGE_TYPE + ".aar"
}


def sdkVersion() {
    return "V" + REAL_SDK_VERVISION
}

task aarRelease(type: Copy) {
    def rootPath = project.buildDir.path

    def aarOutPath = rootPath + "/outputs/aar"
    def aiyouPath = aarOutPath + "/sdk-release.aar"
    def originSdkName = "sdk-release.aar"
    delete aarOutPath
    dependsOn 'assembleRelease'
    from aarOutPath
    into aarOutPath
    include originSdkName
    rename(originSdkName, getAARName())
    def toolkitpath = rootProject.rootDir.path + "/toolkit/build/outputs/aar"
    from toolkitpath
    into aarOutPath
    def toolkitname = "toolkit-release.aar"
    include toolkitname
    rename(toolkitname, getToolkitName())
}
task sync_aars() {
    def jar_name
    def aar_path
    def dest_dir = aarPath
    outputs.upToDateWhen { false }
    task copyJar(type: Copy)
    task copyAAR(type: Copy)
    doLast {
        def aarFile = file(aarPath)
        aarFile.listFiles().each { aar ->
            if (aar.getName().endsWith(".aar") && it.name.contains("debug")) {
                aar_path = aar.getPath()
                jar_name = "libs/" + aar.getName().replace(".aar", ".jar")
                copyAAR {
                    from zipTree(aar_path)
                    into dest_dir
                    rename 'classes.jar', jar_name
                }
                delete aar_path
            }
        }
        android.libraryVariants.all { variant ->
            if (variant.name.contains("debug")) {
                configurations.api.getDependencies().each { configDep ->
                    variant.getCompileClasspath().each { fileDependency ->
                        if (fileDependency.absolutePath.contains(configDep.name)) {
                            println "test " + fileDependency.name + ";dependency.name=" + configDep.name
                            copyJar {
                                from fileDependency.path
                                into aarPath + "/libs/"
                                rename 'classes.jar', configDep.name + ".jar"
                            }
                        }
                    }
                }
            }
        }
        task unZipAAR(type: Copy)
        configurations.compile.findAll {
            it.name.endsWith(".aar") && !it.getPath().contains("support")
        }.collect {
            aar_path = it.getPath()
            jar_name = "libs/" + it.getName().replace(".aar", ".jar")
            unZipAAR {
                from zipTree(aar_path)
                into dest_dir
                rename 'classes.jar', jar_name
                exclude 'AndroidManifest.xml', 'R.txt'
            }
        }
        delete "build/libs/"

        delete "build/outputs/aar/${project.name}-release.aar"
//        task(genSdkJar, type: Jar) {
//            baseName getJarName()
//            from("${aarPath}assets/")
//            file(aarlibPath).listFiles().findAll {
//                it.name.endsWith("release.jar")
//            } collect {
//                from zipTree(it)
//            }
//        }.execute()
    }
}
task sync_jars(dependsOn: sync_aars) {
    doLast {
        //把所有依赖的.jar库都拷贝到build/aar/libs下
        task(copyJarToLibs, type: Copy)
        copyJarToLibs {
            from configurations.compile.findAll {
                it.getName().endsWith(".jar")
            }
            into aarlibPath
        }
    }
}
task copy_jar(dependsOn: sync_jars) {
    doLast {
        def jarpath = buildDir.path + "/jar/"
//    def filetree = fileTree(buildDir.path + "/aar/libs")
        def aarlibs = file(aarlibPath)
        //解压jar包
        task unZipJar(type: Copy)
        aarlibs.listFiles().each { lib ->
            if (lib.getName().endsWith(".jar")) {
                unZipJar {
                    from zipTree(lib)
                    into jarpath
                    exclude {
                        it.path.contains('META-INF') || it.name.startsWith('.')
                    }
                }
            }
        }
        //打出classes.jar
        task(packJar, type: Zip)
        def classPath = jarpath
        packJar {
            baseName = "classes"
            extension = "jar"
            from classPath
            destinationDir = file(aarPath)
        }
        delete classPath
    }
}
task makeaar(dependsOn: copy_jar) {
    doLast {
        task(gen_aar, type: Zip)
        gen_aar {
            //生成最终的aar包，注意libs目录需要被排除
            def dest_dir = aarPath
            def outputpath = buildDir.getPath() + "/libs/"
//        delete outputpath
            baseName = getJarName()
            extension = "aar"
            destinationDir = file(outputpath)
            from dest_dir
            exclude "libs"
        }
    }
}
//afterEvaluate {
//    def dx = tasks.findByName("assembleRelease")
//
//    makeaar.dependsOn dx.taskDependencies.getDependencies(dx)
//    makeJar.dependsOn makeaar
//    dx.dependsOn makeJar
////    disableDebugBuild()
//}
afterEvaluate {
//    configurations.api.canBeResolved = true
//    def dx = tasks.findByName("transformClassesWithDexForDebug")
//
//    makeaar.dependsOn bundleRelease
//    makeJar.dependsOn makeaar
//    dx.dependsOn makeJar
//    project.tasks.getByName("bundleRelease") {
//        it.doLast {
//            println "bundleRelease dolast"
//            sync_aars.execute()
//            sync_jars.execute()
//            copy_jar.execute()
//            makeaar.execute()
//        }
//    }
    project(":toolkit").tasks.getNames().each {
//        println "app task.name=" + it
    }
//        println "app:assemble.dependesOn = "+it.toString()
//    }
    project.tasks.getByName("assembleDebug").outputs.upToDateWhen { false }
    project.tasks.getByName("assembleDebug").finalizedBy makeaar
    //:app:_debugApk
    tasks.matching {
        it.name == 'transformClassesWithDexForDebug'
    }.each { tk ->
        tk.dependsOn(makeaar)
    }
}
gradle.getTaskGraph().whenReady {
    project.tasks.all {
        Task t = it
        String taskName = it.name
        if (it.name == "build") {
            println("--------taskName-----------:" + taskName)
            it.getTaskDependencies().any {
                println("-----------------taskName----dependsOn-----------------:")
                it.getDependencies(t).findAll() {
                    println("----------------------------------:" + it.getPath())
                }
            }
        }
    }
}